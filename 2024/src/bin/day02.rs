use aoc::parse_numbers;

type Report = Vec<u32>;

trait Safe {
    fn is_safe(&self) -> bool;
    fn is_monotonic(&self) -> bool;
    fn pairs_within_range(&self) -> bool;
    fn is_safe_with_dampening(&self) -> bool;
}

impl Safe for Report {
    fn is_safe(&self) -> bool {
        self.is_monotonic() && self.pairs_within_range()
    }

    // test that all the elements in the report are strictly monotonic
    fn is_monotonic(&self) -> bool {
        // use closures for lazy evaluation
        let all_increasing = || {
            self.iter()
                .zip(self[1..].iter())
                .fold(true, |acc, (first, second)| acc && first < second)
        };
        let all_decreasing = || {
            self.iter()
                .zip(self[1..].iter())
                .fold(true, |acc, (first, second)| acc && first > second)
        };
        all_increasing() || all_decreasing()
    }

    // test that all the elements differ by at most 3
    fn pairs_within_range(&self) -> bool {
        self.iter()
            .zip(self[1..].iter())
            .all(|(first, second)| (*first as i64 - *second as i64).abs() <= 3)
    }

    // test all the reports generated by removing on element from the report
    fn is_safe_with_dampening(&self) -> bool {
        for dampened in 0..self.len() {
            let mut dampened_report = self.clone();
            dampened_report.remove(dampened);
            if dampened_report.is_safe() {
                return true;
            }
        }
        false
    }
}

fn process_data(data: String) -> Vec<Report> {
    data.lines().map(|line| parse_numbers(line)).collect()
}

fn part_1(reports: &Vec<Report>) -> usize {
    reports.iter().filter(|report| report.is_safe()).count()
}

fn part_2(reports: &Vec<Report>) -> usize {
    reports
        .iter()
        .filter(|report| report.is_safe_with_dampening())
        .count()
}
fn main() {
    let mut solution = aoc::Solution::day(2);
    let data = solution.data();

    let data = process_data(data);
    solution.part1(part_1(&data)).part2(part_2(&data)).print();
}
